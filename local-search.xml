<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>大语言模型介绍（一）</title>
    <link href="/2024/06/04/%E5%A4%A7%E8%AF%AD%E8%A8%80%E6%A8%A1%E5%9E%8B%E4%BB%8B%E7%BB%8D%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <url>/2024/06/04/%E5%A4%A7%E8%AF%AD%E8%A8%80%E6%A8%A1%E5%9E%8B%E4%BB%8B%E7%BB%8D%EF%BC%88%E4%B8%80%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h1 id="大语言模型"><a href="#大语言模型" class="headerlink" title="大语言模型"></a>大语言模型</h1><h1 id="发展"><a href="#发展" class="headerlink" title="发展"></a>发展</h1><p><img src="/2024/06/04/%E5%A4%A7%E8%AF%AD%E8%A8%80%E6%A8%A1%E5%9E%8B%E4%BB%8B%E7%BB%8D%EF%BC%88%E4%B8%80%EF%BC%89/image-20240604204936144.png" alt="image-20240604204936144"></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>数据结构-图的创建与遍历</title>
    <link href="/2024/06/03/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%9B%BE%E7%9A%84%E5%88%9B%E5%BB%BA%E4%B8%8E%E9%81%8D%E5%8E%86/"/>
    <url>/2024/06/03/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%9B%BE%E7%9A%84%E5%88%9B%E5%BB%BA%E4%B8%8E%E9%81%8D%E5%8E%86/</url>
    
    <content type="html"><![CDATA[<h1 id="有向图的拓扑排序"><a href="#有向图的拓扑排序" class="headerlink" title="# 有向图的拓扑排序"></a># 有向图的拓扑排序</h1><h2 id="图的创建与遍历"><a href="#图的创建与遍历" class="headerlink" title="图的创建与遍历"></a>图的创建与遍历</h2><p>给定节点数和边数，以及构成每条边的两个节点。</p><p><strong>构造图</strong>：</p><p><img src="C:\Users\TJL\AppData\Roaming\Typora\typora-user-images\image-20240603193735331.png" alt="image-20240603193735331"></p><p>要存储上面的图，需要h[N], e[N], ne[N]来表示</p><span id="more"></span><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>;</span><br><span class="line"><span class="type">int</span> h[N];<span class="comment">//存放节点a第一个邻接节点的索引idx</span></span><br><span class="line"><span class="type">int</span> e[N];<span class="comment">//存放索引为idx的边的指向的节点值a</span></span><br><span class="line"><span class="type">int</span> ne[N];<span class="comment">//存放索引idx的与其共享同一个起始点的边的索引idx</span></span><br><span class="line"><span class="type">int</span> idx;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span>&#123;</span><br><span class="line">    e[idx] = b;</span><br><span class="line">    ne[idx] = h[a];</span><br><span class="line">    h[a] = idx++;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="built_in">sizeof</span>(h));</span><br><span class="line">    <span class="type">int</span> n,m;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="type">int</span> a,b;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;m; i++)&#123;</span><br><span class="line">        cin&gt;&gt;a&gt;&gt;b;</span><br><span class="line">        <span class="built_in">add</span>(a,b);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++)&#123;</span><br><span class="line">        <span class="comment">//对点i求其所连接的边</span></span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;以节点&quot;</span>&lt;&lt;i&lt;&lt;<span class="string">&quot;为起始点，与其相邻的边有：&quot;</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = h[i]; j!=<span class="number">-1</span>; j = ne[j])&#123;</span><br><span class="line">            <span class="type">int</span> eb = e[j];</span><br><span class="line">            cout&lt;&lt;eb&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;endl;</span><br><span class="line">        </span><br><span class="line">    &#125; </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="C:\Users\TJL\AppData\Roaming\Typora\typora-user-images\image-20240603193821500.png" alt="image-20240603193821500"></p><h2 id="拓扑排序"><a href="#拓扑排序" class="headerlink" title="拓扑排序"></a>拓扑排序</h2><p><strong>拓扑排序</strong>：</p><p>若一个由图中所有点构成的序列 A 满足：对于图中的每条边 (𝑥,𝑦)，𝑥 在 𝐴 中都出现在 𝑦 之前，则称 𝐴 是该图的一个拓扑序列。</p><p>如：下面的图，能找到序列：1 —— 2 —— 4 —— 3 ——5构成一条拓扑序列</p><p><img src="C:\Users\TJL\AppData\Roaming\Typora\typora-user-images\image-20240603194203015.png" alt="image-20240603194203015"></p><p><strong>判断方法</strong>：</p><ol><li>删除一个入度为0的节点，加入结果集合</li><li>将上述节点对应的有向边都删除，重复第一步</li><li>直到最后没有节点，则该图可找出拓扑序列</li></ol><p><strong>代码实现重点</strong>：</p><ol><li>现把入度为0的节点加到集合的，后面删除该节点对应的边时要先删除：可以使用队列存储</li><li>删除节点a对应的有向边：可以遍历a为起始的连接边，将这些对应的点的入度-1即可</li><li>直到最后没有节点：队列为空时，结果集为整个图的节点个数</li></ol><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>用一个d[N]数组来存储每个点的入度数</p><p>队列q存储所有入度为0的节点</p><p>数组v存储答案</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>;</span><br><span class="line">queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> e[N], ne[N],h[N];</span><br><span class="line"><span class="type">int</span> d[N];<span class="comment">//计算每个点的入度数</span></span><br><span class="line"><span class="type">int</span> idx;</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">int</span> sum;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span>&#123;</span><br><span class="line">    e[idx] = b;</span><br><span class="line">    ne[idx] = h[a];</span><br><span class="line">    h[a] = idx++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">topsort</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//找度为0的点</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i =<span class="number">1</span>; i&lt;=n; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(d[i]==<span class="number">0</span>)&#123;</span><br><span class="line">            q.<span class="built_in">push</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        <span class="type">int</span> u = q.<span class="built_in">front</span>();</span><br><span class="line">        v.<span class="built_in">push_back</span>(u);</span><br><span class="line">        sum++;</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = h[u]; j!=<span class="number">-1</span>; j=ne[j])&#123;</span><br><span class="line">            <span class="type">int</span> c = e[j];</span><br><span class="line">            d[c]--;</span><br><span class="line">            <span class="keyword">if</span>(d[c]==<span class="number">0</span>)&#123;</span><br><span class="line">                q.<span class="built_in">push</span>(c);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(sum == n)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> i : v)&#123;</span><br><span class="line">            cout&lt;&lt;i&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        cout&lt;&lt;<span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="built_in">sizeof</span>(h));</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="type">int</span> a,b;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i =<span class="number">0</span> ;i&lt;m ;i++)&#123;</span><br><span class="line">        cin&gt;&gt;a&gt;&gt;b;</span><br><span class="line">        <span class="built_in">add</span>(a,b);</span><br><span class="line">        d[b]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">topsort</span>();</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>前馈神经网络</title>
    <link href="/2024/06/03/%E5%89%8D%E9%A6%88%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/"/>
    <url>/2024/06/03/%E5%89%8D%E9%A6%88%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/</url>
    
    <content type="html"><![CDATA[<h1 id="前馈神经网络"><a href="#前馈神经网络" class="headerlink" title="前馈神经网络"></a>前馈神经网络</h1><h2 id="感知机模型"><a href="#感知机模型" class="headerlink" title="感知机模型"></a>感知机模型</h2><h3 id="单层感知机"><a href="#单层感知机" class="headerlink" title="单层感知机"></a>单层感知机</h3><p>输入层：感知层，n个神经节点，无信息处理能力，只负责引入外部信息X。</p><p>处理层：m个神经接点，每节点均有信息处理能力，m个节点向外部处理输出信息，构成输出列向量Y。</p><p>两层间连接权值用权值列向量$W_j$表示，m个权向量构成单层感知器的权值矩阵W。</p><span id="more"></span><p>$W_j&#x3D;[w_{1j} w_{2j} …w{ij}…w_{nj}]^T $</p><p><img src="C:\Users\TJL\AppData\Roaming\Typora\typora-user-images\image-20240603083000147.png" alt="image-20240603083000147"></p><p>离散型单计算层感知器采用符号型转移函数，则j节点输出为：</p><p><img src="C:\Users\TJL\AppData\Roaming\Typora\typora-user-images\image-20240603083518628.png" alt="image-20240603083518628"></p><h4 id="单计算节点感知机"><a href="#单计算节点感知机" class="headerlink" title="单计算节点感知机"></a>单计算节点感知机</h4><p>单计算节点感知器实际上就是一个M-P神经元模型。</p><p><img src="C:\Users\TJL\AppData\Roaming\Typora\typora-user-images\image-20240603083651224.png" alt="image-20240603083651224"></p><p><img src="C:\Users\TJL\AppData\Roaming\Typora\typora-user-images\image-20240603083738943.png" alt="image-20240603083738943"></p><p><strong>功能：</strong></p><p>输入向量$X&#x3D;[x_1 x_2 …x_n]^T$,则n个输入分量构成几何n维空间，</p><p><img src="C:\Users\TJL\AppData\Roaming\Typora\typora-user-images\image-20240603083928471.png" alt="image-20240603083928471"></p><p>该超平面将样本分成2类。</p><p>一个简单的单计算节点感知器具有分类功能，其分类原理是将分类知识存储于感知器的权向量（包括阈值）中，由权向量确定的分类判决界面（线），可将输入模式分为两类。</p><p>举例：</p><ol><li><p>功能”<strong>与</strong>“</p><p><img src="C:\Users\TJL\AppData\Roaming\Typora\typora-user-images\image-20240603084201492.png" alt="image-20240603084201492"></p></li><li><p>功能”<strong>或</strong>“</p><p><img src="C:\Users\TJL\AppData\Roaming\Typora\typora-user-images\image-20240603084230370.png" alt="image-20240603084230370"></p></li><li><p>功能”<strong>异或</strong>”</p><p><img src="C:\Users\TJL\AppData\Roaming\Typora\typora-user-images\image-20240603084253856.png" alt="image-20240603084253856"></p><p>确定的分类判决方程是线性方程,因而只能解决线性可分问题的分类,不能解决线性不可分问题.<br>这称为单计算层感知器的局限性.</p></li></ol><h3 id="多层感知机"><a href="#多层感知机" class="headerlink" title="多层感知机"></a>多层感知机</h3><p>单计算层感知器只能解决线性可分问题,多层感知器可解决线性不可分问题。</p><p>输出层节点以隐层两节点y1,y2的输出作为输入,其结构也相当于一个符号单元。</p><p><img src="C:\Users\TJL\AppData\Roaming\Typora\typora-user-images\image-20240603085523918.png" alt="image-20240603085523918"></p><p><img src="C:\Users\TJL\AppData\Roaming\Typora\typora-user-images\image-20240603085647369.png" alt="image-20240603085647369"></p><p>1、2两符号单元确定两条分界直线s1和s2,可构成开放式凸域。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>预训练模型</title>
    <link href="/2024/06/02/%E9%A2%84%E8%AE%AD%E7%BB%83%E6%A8%A1%E5%9E%8B/"/>
    <url>/2024/06/02/%E9%A2%84%E8%AE%AD%E7%BB%83%E6%A8%A1%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="预训练模型"><a href="#预训练模型" class="headerlink" title="预训练模型"></a>预训练模型</h1><h2 id="预训练简介"><a href="#预训练简介" class="headerlink" title="预训练简介"></a>预训练简介</h2><p><strong>预训练</strong>：通过子监督学习从大规模数据里获取与具体任务无关的预训练模型的过程。</p><p>预训练任务：</p><ol><li><p>掩码语言模型（编码器）：将一些位置的token替换成特殊的[MASK]字符，预测这些被替换的字符</p><p><img src="C:\Users\TJL\AppData\Roaming\Typora\typora-user-images\image-20240602212830234.png" alt="image-20240602212830234"></p><p>只计算掩码部分的loss，其余部分不计算loss</p><span id="more"></span></li><li><p>因果语言模型（解码器）：输入完整序列，基于上文预测当前token</p><p><img src="C:\Users\TJL\AppData\Roaming\Typora\typora-user-images\image-20240602213105457.png" alt="image-20240602213105457"></p><p>eos代表句子结束</p></li><li><p>序列到序列模型：编码器解码器方式，预测部分放到解码器里面</p><p>只计算解码器的loss，不计算解码器部分</p></li></ol><h2 id="文本摘要"><a href="#文本摘要" class="headerlink" title="文本摘要"></a>文本摘要</h2><p><strong>文本摘要：</strong>输入长文本，将长文本转成简短的摘要</p><p>任务类别：单文档单语言摘要</p><p>评价指标：Rouge-1(基于1-gram) Rouge-2(基于2-gram) Rouge-L(基于LCS)</p><table><thead><tr><th>原始文本</th><th>1-gram</th><th>2-gram</th></tr></thead><tbody><tr><td>今天不错</td><td>今 天 不 错</td><td>今天 天不 不错</td></tr><tr><td>今天太阳不错</td><td>今 天 太 阳 不 错</td><td>今天 天太 太阳 阳不 不错</td></tr></tbody></table><p>Rouge-1   P &#x3D; 4&#x2F;4   R&#x3D;4&#x2F;6  F &#x3D; 2PR(P+R)</p><p>Rouge-2   P &#x3D; 2&#x2F;3   R&#x3D;2&#x2F;5</p><p>LCS(最长公共子序列)   P &#x3D; 4&#x2F;4   R&#x3D;4&#x2F;6</p><h3 id="数据处理"><a href="#数据处理" class="headerlink" title="数据处理"></a>数据处理</h3><p>input和labels分开处理，labels最后一定要有eos_token</p><p>labels不仅是标签，还是解码器的输入</p><p>数据集：</p><h2 id="对话机器人"><a href="#对话机器人" class="headerlink" title="对话机器人"></a>对话机器人</h2><h1 id="参数微调fine-tuning"><a href="#参数微调fine-tuning" class="headerlink" title="参数微调fine-tuning"></a>参数微调fine-tuning</h1><h2 id="beat-fit"><a href="#beat-fit" class="headerlink" title="beat-fit"></a>beat-fit</h2><p>只对bias求梯度，其他的参数冻结</p><h2 id="prompt-Tuning"><a href="#prompt-Tuning" class="headerlink" title="prompt-Tuning"></a>prompt-Tuning</h2><p>冻结主模型所有参数，在训练数据前加入一小段prompt，只训练prompt的embedding层。</p><p>hard prompt：指定prompt</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">config = PromptTuningConfig(task_type=TaskType.CAUSAL_LM, prompt_tuning_init=PromptTuningInit.TEXT, </span><br><span class="line">                            prompt_tuning_init_text = <span class="string">&quot;下面是一段人与机器人的对话。&quot;</span>,</span><br><span class="line">                            num_virtual_tokens  = <span class="built_in">len</span>(tokenizer(<span class="string">&quot;下面是一段人与机器人的对话。&quot;</span>)[<span class="string">&quot;input_ids&quot;</span>]), </span><br><span class="line">                            tokenizer_name_or_path = <span class="string">&quot;Langboat/bloom-389m-zh&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>soft prompt：不指定prompt，让模型自行学习  ，对模型需要进行适配多轮才能有好效果</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Transformer</title>
    <link href="/2024/06/02/Transformer/"/>
    <url>/2024/06/02/Transformer/</url>
    
    <content type="html"><![CDATA[<h1 id="Transformer的理解"><a href="#Transformer的理解" class="headerlink" title="Transformer的理解"></a>Transformer的理解</h1><h1 id="transformer"><a href="#transformer" class="headerlink" title="transformer"></a>transformer</h1><p><img src="https://img-blog.csdnimg.cn/direct/8a8c78c6941948a1827a013fe1da2bb3.png" alt="在这里插入图片描述"></p><h1 id="ENCODER"><a href="#ENCODER" class="headerlink" title="ENCODER"></a>ENCODER</h1><p><img src="https://img-blog.csdnimg.cn/direct/e93387aeabd749789fcb9379ef913203.png" alt="在这里插入图片描述"></p><h2 id="输入部分"><a href="#输入部分" class="headerlink" title="输入部分"></a>输入部分</h2><p>对拆分后的语句x &#x3D; [batch_size, seq_len]进行以下操作</p><span id="more"></span><ol><li>Embedding<br>将离散的输入（如单词索引或其他类别特征）转换为稠密的实数向量，以便可以在神经网络中使用。</li><li>位置编码<br>与RNN相比，RNN是一个字一个字的输入，自然每个字的顺序关系信息就会保留下来。但在Encoder中，一个句子的每一个字（词）是并行计算的（下一节解释），所以我们在输入的时候需要提前引入位置信息。<br>位置信息由： pos（一句话中的第几个字） 和 i （这个字编码成向量后的第i维) 来确定<br>下面是Positional Encoding的公式：<br>i为 偶 数 时 ,  $PE_{pos, i}&#x3D; sin( pos&#x2F; 10000^{2i&#x2F; d_{model}})$<br>i为 奇 数 时 ,  $PE_{pos, i}&#x3D; cos( pos&#x2F; 10000^{2i&#x2F; d_{model}})$<br>$d_{model}$指想用多长的 vector 来表达一个词(embedding_dim)</li></ol><p>通过输入部分<br>x： [batch_size, seq_len, embedding_dim]</p><p><img src="https://img-blog.csdnimg.cn/direct/2cd5cdb5641248179485166cd2044e44.png" alt="在这里插入图片描述"></p><h2 id="多头注意力机制"><a href="#多头注意力机制" class="headerlink" title="多头注意力机制"></a>多头注意力机制</h2><ol><li>单头注意力机制<br>对一句话中第i个字的字向量$a_i$，产生三个矩阵Q, K ，V<br>Q,K,V的维度都为[batch_size, seq_len, embedding_dim]</li></ol><p>将$a_i$分别与上面三个矩阵相乘，得到三个向量$q_i, k_i, v_i$<br>如果要计算第1个字向量与句子中所有字向量的注意力：<br>将查询向量$q_1$与 所有的字向量的键向量$k_i$相乘得到$alpha_{10}, alpha_{11},…,alpha_{1,seqlen}$<br>将这写数值进行softmax处理后， 分别与$v_i$相乘再合加得到最终结果$b_1$</p><p><img src="https://img-blog.csdnimg.cn/direct/1e55284965a44375b70d7f35a5869142.png" alt="在这里插入图片描述"></p><ol start="2"><li>多头注意力机制<br>把$Q,K,V$三个大矩阵变成n个小矩阵（seq_len, embedding_dim&#x2F;n)     n&#x3D;8<br>用上节相同的方式计算8个矩阵，然后把每一个head-Attention计算出来的b矩阵拼在一起，作为输出</li></ol><h2 id="Add-LN"><a href="#Add-LN" class="headerlink" title="Add&amp;LN"></a>Add&amp;LN</h2><p>Add是用了残差神经网络的思想，也就是把Multi-Head Attention的输入的a矩阵直接加上Multi-Head Attention的输出b矩阵（好处是可以让网络训练的更深）得到的和 $\bar{b}$矩阵</p><p>再在经过Layer normalization（归一化，作用加快训练速度，加速收敛）把<br> 每一行（也就是每个句子）做归一为标准正态分布，最后得到$\hat{b}$<br>BN 和 LN：</p><ol><li>LN： 在一个样本内做归一化 适于RNN,transformer</li><li>BN： 对batch_size里面的样本按对应的特征做归一化  适于CNN<br><img src="https://img-blog.csdnimg.cn/direct/8f699727d3214959addb03e90822d558.png" alt="在这里插入图片描述"></li></ol><h2 id="Feed-forward前馈神经网络"><a href="#Feed-forward前馈神经网络" class="headerlink" title="Feed_forward前馈神经网络"></a>Feed_forward前馈神经网络</h2><p>把Add &amp; Layer normalization输出$\hat{b}$，经过两个全连接层，再经过Add &amp; Layer normalization得到最后输出 o 矩阵</p><h1 id="DECODER"><a href="#DECODER" class="headerlink" title="DECODER"></a>DECODER</h1><h2 id="masked-多头注意力机制"><a href="#masked-多头注意力机制" class="headerlink" title="masked_多头注意力机制"></a>masked_多头注意力机制</h2><p> 比如我们在中英文翻译时候，会先把”我是学生”整个句子输入到Encoder中，得到最后一层的输出后，才会在Decoder输入”S I am a student”（s表示开始）,但是”S I am a student”这个句子我们不会一起输入，而是在T0时刻先输入”S”预测，预测第一个词”I”；在下一个T1时刻，同时输入”S”和”I”到Decoder预测下一个单词”am”；然后在T2时刻把”S,I,am”同时输入到Decoder预测下一个单词”a”,依次把整个句子输入到Decoder,预测出”I am a student E”</p><h2 id="多头注意力机制-1"><a href="#多头注意力机制-1" class="headerlink" title="多头注意力机制"></a>多头注意力机制</h2><p>Decoder 的 Multi-Head Attention 的输入来自两部分，<br>K，V 矩阵来自Encoder的输出，<br>Q 矩阵来自 Masked Multi-Head Attention 的输出<br><img src="https://img-blog.csdnimg.cn/direct/3f06bddb5c124448b71e5df6a4c2429d.png" alt="在这里插入图片描述"></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>first-blog</title>
    <link href="/2024/06/02/first-blog/"/>
    <url>/2024/06/02/first-blog/</url>
    
    <content type="html"><![CDATA[<h1 id="数据结构复习篇1——哈夫曼树"><a href="#数据结构复习篇1——哈夫曼树" class="headerlink" title="数据结构复习篇1——哈夫曼树"></a>数据结构复习篇1——哈夫曼树</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><ol><li><p>结点的带权路径：从根结点到该结点之间的路径长度与该结点的权的乘积</p></li><li><p>树的带权路径：所有叶子结点的带权路径长度之和</p><p>举例：</p><p><img src="C:\Users\TJL\AppData\Roaming\Typora\typora-user-images\image-20240602203936732.png" alt="image-20240602203936732"></p></li><li><p>哈夫曼树：将n个权值作为二叉树的n个叶子结点，若树的带权路径长度达到最小，则这棵树被称为哈夫曼树</p></li></ol><span id="more"></span><h2 id="构造哈夫曼树"><a href="#构造哈夫曼树" class="headerlink" title="构造哈夫曼树"></a>构造哈夫曼树</h2><p>给我们n个结点，如何构造出一颗哈夫曼树呢？</p><p>在这里，我们可以尝试使用贪心的策略，如果要是的WPL最小，那权值大的点应该放在深度很小的地方，权值小的点应该放到底层，即深度很大的地方。所以每次构造时选择两个权值最小的结点进行构造。</p><p>举例：给定4，7，9，10这四个结点，如何构造一个是的WPL最小的二叉树呢？</p><p><strong>·Step1:</strong> 从这个结点集合中选择权值最小的两个点，组成一个新结点。</p><p>在这个例子里面，选择 4 和 7 ，构造成新的点11</p><p><strong>·Step2:</strong> 把选过的结点从结点集合排出，新结点11加入结点集合，重复step1，直至结点集合里面只有一个结点为止。</p><p>根据上述步骤，最后组成的哈夫曼树如图所示。</p><p><img src="C:\Users\TJL\AppData\Roaming\Typora\typora-user-images\image-20240602204852758.png" alt="image-20240602204852758"></p><h2 id="代码实践"><a href="#代码实践" class="headerlink" title="代码实践"></a>代码实践</h2><p>对于上述的方法，很容易想到如果要构造一个哈夫曼树可以使用最小堆（priority_queue）实现。每次从堆中弹出的两个结点即是我们要取的构造新结点的组成结点。</p><p>这里，我们将二叉树扩展到K叉树，即每个父结点由K个字节的组成。</p><h3 id="荷马史诗"><a href="#荷马史诗" class="headerlink" title="荷马史诗"></a>荷马史诗</h3><p>引入问题：（该问题来自acwing<a href="https://www.acwing.com/problem/content/151/">149. 荷马史诗 - AcWing题库</a>)</p><p>一部《荷马史诗》中有 n 种不同的单词，从 1到 n 进行编号。其中第 i𝑖 种单词出现的总次数为 𝑤𝑖。</p><p>达达想要用 𝑘 进制串 𝑠𝑖 来替换第 𝑖 种单词，使得其满足如下要求:</p><p>对于任意的 1≤i,j≤n，i≠j1≤𝑖,𝑗≤𝑛，𝑖≠𝑗，都有：𝑠𝑖 不是 𝑠𝑗 的前缀。</p><p>现在达达想要知道，如何选择 𝑠𝑖，才能使替换以后得到的新的《荷马史诗》长度最小。</p><p>在确保总长度最小的情况下，达达还想知道最长的 𝑠𝑖 的最短长度是多少？</p><p>一个字符串被称为 k𝑘 进制字符串，当且仅当它的每个字符是 0 到 𝑘−1 之间（包括 0 和 𝑘−1）的整数。</p><p>字符串 𝑆𝑡𝑟1 被称为字符串 𝑆𝑡𝑟2 的前缀，当且仅当：存在 1≤t≤m1≤𝑡≤𝑚，使得 𝑆𝑡𝑟1&#x3D;𝑆𝑡𝑟2[1..𝑡]。</p><p>其中，𝑚 是字符串𝑆𝑡𝑟2 的长度，𝑆𝑡𝑟2[1..𝑡] 表示𝑆𝑡𝑟2 的前 𝑡 个字符组成的字符串。</p><p><strong>注意</strong>: 请使用 64 位整数进行输入输出、储存和计算。</p><p>输出文件包括 2 行。</p><p>第 1 行输出 1 个整数，为《荷马史诗》经过重新编码以后的最短长度。</p><p>第 2 行输出 1 个整数，为保证最短总长度的情况下，最长字符串 𝑠𝑖 的最短长度。</p><p>对于该问题，很明显可以看出需要我们构造一个k叉树使其$WPL$达到最小，另外，对于权值相同的结点，要优先考虑深度小的来构造，避免树的深度过大。</p><p>下面是代码实现。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span>  LL;</span><br><span class="line">priority_queue&lt;pair&lt;LL, <span class="type">int</span>&gt;, vector&lt;pair&lt;LL, <span class="type">int</span>&gt;&gt;, greater&lt;pair&lt;LL, <span class="type">int</span>&gt;&gt;&gt; h;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n,k;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;k;</span><br><span class="line">    LL a;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;n; i++)&#123;</span><br><span class="line">        cin&gt;&gt;a;</span><br><span class="line">        h.<span class="built_in">push</span>(&#123;a,<span class="number">0</span>&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//对于填不满k叉树的结点，补0来处理</span></span><br><span class="line">    <span class="keyword">while</span>((n<span class="number">-1</span>)%(k<span class="number">-1</span>))&#123;</span><br><span class="line">        h.<span class="built_in">push</span>(&#123;<span class="number">0</span>,<span class="number">0</span>&#125;);</span><br><span class="line">        n++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    LL res = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(h.<span class="built_in">size</span>()&gt;<span class="number">1</span>)&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> depth = <span class="number">0</span>;</span><br><span class="line">        LL s = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;k; i++)&#123;</span><br><span class="line">            <span class="keyword">auto</span> p = h.<span class="built_in">top</span>();</span><br><span class="line">            s += p.first;</span><br><span class="line">            depth = <span class="built_in">max</span>(depth, p.second);</span><br><span class="line">            h.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        res += s;</span><br><span class="line">        h.<span class="built_in">push</span>(&#123;s, depth+<span class="number">1</span>&#125;);</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;res&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;h.<span class="built_in">top</span>().second&lt;&lt;endl;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2024/06/02/hello-world/"/>
    <url>/2024/06/02/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
